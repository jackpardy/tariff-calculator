{{define "content"}}
<div class="container" x-data="tariffCalculatorStore()" x-init="init()">

    <input type="hidden" name="routineData" :value="JSON.stringify(routine)">

    <div class="box">
        <h3 class="title is-4">Skill Calculator</h3>
        <div id="skill-form-wrapper">
            {{/* This inner div will now be the target for reloads */}}
            <div id="skill-form-content"
                 hx-trigger="load"
            hx-get="/skill-form-fragment"
            hx-target="this"
            hx-swap="outerHTML"
            x-init="console.log('Loading initial skill form content...')">
            <p>Loading form...</p>
        </div>
    </div>
</div>

<div id="evaluation-preview" class="box" style="min-height: 100px;">
    {{/* Content loaded by HTMX from /evaluate-skill-fragment */}}
</div>

<div class="box">
    <h3 class="title is-4">Routine Builder</h3>
    <div id="routine-skills" class="routine-skills">
        <template x-for="(skill, index) in routine" :key="index">
            <div class="routine-skill box mb-2"
                 :class="{
                        'invalid-transition': validationResults?.invalidTransitions?.includes(index),
                        'invalid-landing': validationResults?.invalidLandings?.includes(index),
                        'duplicate-skill': validationResults?.duplicates?.includes(index),
                        'dragging': draggedIndex === index
                     }"
                 draggable="true"
                 @dragstart="handleDragStart($event, index)"
                 @dragover.prevent="handleDragOver($event, index)"
                 @dragleave="handleDragLeave($event)"
                 @drop="handleDrop($event, index)"
                 @dragend="handleDragEnd($event)"
                 @touchstart="handleTouchStart($event, index)"
                 @touchmove="handleTouchMove($event)"
                 @touchend="handleTouchEnd($event)"
                 @touchcancel="handleTouchEnd($event)">

                {{/* Single columns div for the main skill info row */}}
                <div class="columns is-mobile is-vcentered is-flex-grow-1">
                    {{/* Skill Details Columns */}}
                    <div class="column is-4-mobile is-3-tablet"><p><strong x-text="`${index + 1}. ${skill.name || 'Custom Skill'}`"></strong></p><p><span x-text="Math.abs(skill.rotation)"></span> <span x-text="skill.backward ? 'B' : 'F'"></span></p></div>
                    <div class="column is-2-mobile is-2-tablet"><p x-text="(skill.twist_distribution || []).join(' | ')"></p></div>
                    <div class="column is-3-mobile is-2-tablet"><p x-text="`${skill.takeoff_position} ‚Üí ${skill.landing_position || calculateLanding(skill)}`"></p></div>
                    <div class="column is-2-mobile is-2-tablet"><p x-text="skill.shape"></p></div>
                    <div class="column is-2-mobile is-1-tablet"><p class="has-text-primary" x-text="skill.tariff.toFixed(2)"></p></div>

                    {{/* Controls Column - Buttons Go Here */}}
                    <div class="column is-4-mobile is-2-tablet">
                        <div class="buttons are-small is-flex is-justify-content-flex-end">
                            {{/* Up Button */}}
                            <button class="button" title="Move Up" @click="moveSkillUp(index)" :disabled="index === 0">‚Üë</button>
                            {{/* Down Button */}}
                            <button class="button" title="Move Down" @click="moveSkillDown(index)" :disabled="index === routine.length - 1">‚Üì</button>
                            {{/* Edit Button */}}
                            <button class="button is-info is-small" title="Edit" @click="editSkill(index)">Edit</button>
                            {{/* Remove Button */}}
                            <button class="button is-danger is-small delete" title="Remove" @click="removeSkill(index)"></button>
                        </div>
                    </div>
                </div> {{/* End main columns div */}}

                {{/* Validation Message Display */}}
                <div x-show="validationResults?.messages?.[index]" class="columns is-mobile">
                    <div class="column is-12">
                        <p class="transition-status is-size-7 mt-1 has-text-danger"
                           x-text="validationResults?.messages?.[index] ?? ''"></p>
                    </div>
                </div>
            </div> {{/* End routine-skill div */}}
        </template>

        <template x-if="routine.length === 0">
            <p class="has-text-grey">Add skills using the form above.</p>
        </template>
    </div>

    <div id="routine-results" class="mt-4">
        <div class="card">
            <div class="card-content">
                <p class="title">Total Tariff: <span x-text="validationResults?.totalTariff?.toFixed(2) ?? '0.00'"></span></p>
                <p class="subtitle"><span x-text="routine.length"></span> of 10 skills</p>
                <p x-show="validationResults?.rawTariff > validationResults?.totalTariff" class="subtitle tariff-difference">(Raw Total: <span x-text="validationResults?.rawTariff?.toFixed(2)"></span>)</p>
                <div class="validation-messages mt-3">
                    <p x-show="validationResults?.routineTooLong" class="has-text-warning mb-2">‚ö†Ô∏è Routine has more than 10 skills (only first 10 non-duplicates count toward Tariff).</p>
                    <p x-show="validationResults?.duplicates?.length > 0" class="has-text-warning mb-2">‚ö†Ô∏è Duplicate skills only count once toward total!</p>
                    <p x-show="validationResults?.invalidTransitions?.length > 0" class="has-text-danger">‚ùå Invalid transitions detected.</p>
                    <p x-show="validationResults?.invalidLandings?.length > 0" class="has-text-landing-warning">üö´ Invalid landing positions detected.</p>
                    <p x-show="validationResults?.tenthSkillWarning" class="has-text-tenth-warning">üéØ 10th skill must land on feet!</p>
                </div>
            </div>
        </div>
    </div>
</div>

<div x-show="toast.show" x-transition
     class="notification is-fixed-bottom-right"
     :class="toast.type === 'error' ? 'is-danger' : 'is-info'">
    <button class="delete" @click="toast.show = false"></button>
    <span x-text="toast.message"></span>
</div>

</div><script>
    function tariffCalculatorStore() {
        return {
            // --- Properties ---
            routine: [],
            editingIndex: null,
            validationResults: { skills: [], valid: true, messages: [], invalidTransitions: [], invalidLandings: [], tenthSkillWarning: false, routineTooLong: false, duplicates: [], totalTariff: 0.0, rawTariff: 0.0 },
            toast: { show: false, message: '', type: 'info' },
            draggedIndex: null,
            dropIndex: null,
            isDragging: false,
            touchStartY: null,
            draggedElement: null,
            _processingCalculation: false,

            // --- Initialization ---
            init() {
                // console.log('Alpine store initialized');
                const savedRoutine = localStorage.getItem('trampolineRoutine');
                if (savedRoutine) { try { this.routine = JSON.parse(savedRoutine); } catch (e) { console.error('Failed to parse saved routine:', e); localStorage.removeItem('trampolineRoutine'); } }

                this.$watch('routine', (newRoutine) => { this.validateRoutineBackend(); localStorage.setItem('trampolineRoutine', JSON.stringify(newRoutine)); });

                // Central HTMX Event Listener
                document.body.addEventListener('htmx:afterRequest', (event) => {
                    const xhr = event.detail.xhr;
                    const requestPath = event.detail.requestConfig?.path;
                    const target = event.detail.target;
                    const swapMode = event.detail.requestConfig?.verb === 'get' ? event.detail.requestConfig?.swapStyle : null; // Get swap style for relevant requests

                    // Handle /validate-routine-client-state Response
                    if (requestPath === '/validate-routine-client-state') {
                        if (xhr.status === 200) {
                            try {
                                const results = JSON.parse(xhr.responseText);
                                this.validationResults = { skills: results.skills || [], valid: results.valid === true, messages: results.messages || [], invalidTransitions: results.invalidTransitions || [], invalidLandings: results.invalidLandings || [], tenthSkillWarning: results.tenthSkillWarning === true, routineTooLong: results.routineTooLong === true, duplicates: results.duplicates || [], totalTariff: results.totalTariff || 0.0, rawTariff: results.rawTariff || 0.0 };
                            } catch(e) { console.error("Error parsing validation response:", e); this.showToast('Could not update validation.', 'error'); }
                        } else { console.error(`/validate-routine-client-state request failed: ${xhr.status}`); this.showToast('Validation update failed.', 'error'); }
                    }
                    // Handle Form Fragment Load (covers initial, common skill, cancel edit, update)
                    else if (target?.id === 'skill-form-wrapper' && swapMode === 'innerHTML' || target?.id === 'skill-form-content' && swapMode === 'outerHTML') {
                        const rotationInput = document.getElementById('rotation');
                        if(rotationInput){ this.updateTwistInputs(rotationInput.value); }
                    }
                }); // End listener

                this.validateRoutineBackend(); // Initial validation
            }, // End init

            // --- Actions ---
            addSkill(skillData) {
                if (this.routine.length >= 10) { this.showToast('Warning: Routines typically have 10 skills.', 'warning'); }
                const newSkill = { name: skillData.name || 'Custom Skill', rotation: skillData.rotation, twist_distribution: skillData.twist_distribution || [], takeoff_position: skillData.takeoff_position, shape: skillData.shape, backward: skillData.backward, seat_landing: skillData.seat_landing, tariff: skillData.tariff, landing_position: skillData.landing_position };
                this.routine.push(newSkill);
            },
            removeSkill(index) { if (index >= 0 && index < this.routine.length) { this.routine.splice(index, 1); if (this.editingIndex === index) this.cancelEdit(); else if (this.editingIndex > index) this.editingIndex--; } },
            editSkill(index) { this.editingIndex = index; htmx.ajax('GET', `/edit-skill-form-data/${index}`, { target: '#skill-form-wrapper', swap: 'innerHTML', values: { routineData: JSON.stringify(this.routine) }, indicator: '#skill-form-wrapper' }).catch(err => { console.error("Failed to load edit form", err); this.showToast("Failed to load edit form.", "error"); this.editingIndex = null; }); },
            handleUpdateSkill(index, formDataObject) { // formDataObject comes directly from getFormData

                if (index === null || index < 0 || index >= this.routine.length) {

                    this.showToast('Error: Invalid skill index for update.', 'error');
                    return;
                }

                // Use formDataObject directly from getFormData (parseFormDataForCalc removed)
                const skillData = formDataObject;


                this.calculateSkill(skillData, (calculatedSkill) => {
                    // This callback runs ONLY on successful calculation/JSON parsing

                    if (calculatedSkill) {
                        // --- Add Logging Around Splice ---


                        if (index >= this.routine.length) {

                            this.showToast('Error updating skill: index mismatch.', 'error');
                            return;
                        }

                        // Perform the replacement - Ensure 'calculatedSkill' has correct twists/backward from backend response
                        this.routine.splice(index, 1, calculatedSkill);


                        // --- End Logging Around Splice ---


                        this.cancelEdit(); // Call the updated cancelEdit
                    } else {

                        this.showToast('Failed to recalculate skill during update.', 'error');
                    }
                });

            },
            cancelEdit() { this.editingIndex = null; htmx.ajax('GET', '/skill-form-fragment', { target: '#skill-form-wrapper', swap: 'innerHTML', indicator: '#skill-form-wrapper' }).then(() => { const rotationInput = document.getElementById('rotation'); if(rotationInput){ this.updateTwistInputs(rotationInput.value); } }).catch(err => { console.error("Failed to load empty form", err); this.showToast("Failed to load empty form.", "error"); }); },
            moveSkillUp(index) { if (index > 0) { [this.routine[index], this.routine[index - 1]] = [this.routine[index - 1], this.routine[index]]; if (this.editingIndex === index) this.editingIndex--; else if (this.editingIndex === index - 1) this.editingIndex++; } },
            moveSkillDown(index) { if (index < this.routine.length - 1) { [this.routine[index], this.routine[index + 1]] = [this.routine[index + 1], this.routine[index]]; if (this.editingIndex === index) this.editingIndex++; else if (this.editingIndex === index + 1) this.editingIndex--; } },

            // --- Client Side Calculation / Update ---
            updateTwistInputs(rotationValue) { const rotation = Math.abs(parseInt(rotationValue) || 0); const phases = this.calculatePhases(rotation); const twistInputs = document.querySelectorAll('#main-form .twist-rotation'); twistInputs.forEach((input, i) => { const phaseNum = i + 1; const shouldBeEnabled = (phaseNum <= phases); input.disabled = !shouldBeEnabled; input.style.opacity = shouldBeEnabled ? '1' : '0.5'; }); },

            // --- Backend Interaction ---
            validateRoutineBackend() { htmx.ajax('POST', '/validate-routine-client-state', { values: { routineData: JSON.stringify(this.routine) }, swap: 'none' }).catch(error => { console.error('Validation AJAX initiation error:', error); this.showToast('Failed to connect for validation.', 'error'); }); },
            calculateSkill(skillData, callbackOnSuccess) {
                if (typeof callbackOnSuccess !== 'function') { console.error("calculateSkill callback missing!"); return; } if (this._processingCalculation) { console.warn("Calculation already in progress."); return; } this._processingCalculation = true; const payload = { name: skillData.name || "Custom Skill", rotation: skillData.rotation, twist_distribution: skillData.twist_distribution || [], takeoff_position: String(skillData.takeoff_position), shape: String(skillData.shape), backward: skillData.backward, seat_landing: skillData.seat_landing }; const jsonPayload = JSON.stringify(payload); if (!jsonPayload || jsonPayload === "{}") { console.error("Payload is empty/invalid before fetch!"); this.showToast("Cannot calculate empty skill.", "error"); this._processingCalculation = false; return; }
                fetch('/calculate-skill', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: jsonPayload })
                    .then(response => { if (!response.ok) { throw new Error(`HTTP error ${response.status}`); } return response.json(); })
                    .then(calculatedData => { callbackOnSuccess(calculatedData); })
                    .catch(error => { console.error('calculateSkill Fetch error:', error); this.showToast(`Calculation Request Failed: ${error.message}`, 'error'); })
                    .finally(() => { this._processingCalculation = false; });
            },
            handleAddSkillClick(event) { if(event) { event.stopPropagation(); } const form = document.getElementById('main-form'); if (!form) { this.showToast('Form not found.', 'error'); return; } const skillData = this.getFormData('#main-form'); this.calculateSkill(skillData, (calculatedSkill) => { if (calculatedSkill) { this.addSkill(calculatedSkill); /* Form reload handled by HX-Trigger from Go */ } }); },
            addEvaluatedSkillToRoutine() { const previewDiv = document.getElementById('evaluation-preview'); const skillJson = previewDiv.querySelector('[data-skill-data]')?.dataset.skillData; if (skillJson) { try { const skill = JSON.parse(skillJson); this.addSkill(skill); previewDiv.innerHTML = ''; } catch(e) { console.error("Error parsing evaluated skill data:", e); this.showToast('Could not add evaluated skill.', 'error'); } } else { console.warn("Could not find skill data in evaluation preview."); } },

            // --- Utilities ---
            calculateLanding(skill) { const BP = { F: 0, Fr: 1, B: 3, S: 4, I: -1 }; const PA = { 'Feet': 0, 'Front': 1, 'Back': 3, 'Seat': 0, 'feet': 0, 'front': 1, 'back': 3, 'seat': 0 }; const PN = ["Feet", "Front", "Back", "Seat", "Invalid"]; let tr = 0; const ta = PA[skill.takeoff_position]; if (ta === undefined) return PN[BP.I]; if (skill.backward) { tr = ta - skill.rotation; } else { tr = ta + skill.rotation; } let tt = (skill.twist_distribution || []).reduce((s, t) => s + t, 0); let fp = BP.I; let ak = (tr % 4); if (ak < 0) ak += 4; if (tt % 2 !== 0) { if (ak === 1) ak = 3; else if (ak === 3) ak = 1; } if (ak === 0) fp = BP.F; else if (ak === 1) fp = BP.Fr; else if (ak === 3) fp = BP.B; if (skill.seat_landing) { return (fp === BP.F) ? PN[BP.S] : PN[BP.I]; } return PN[fp] ?? PN[BP.I]; },
            showToast(message, type = 'info') { this.toast.message = message; this.toast.type = type; this.toast.show = true; setTimeout(() => this.toast.show = false, 3000); },
            isFirstOccurrence(index) { if (index < 0 || index >= this.routine.length) return false; const cs = this.routine[index]; for(let i=0; i < index; i++){ if (this.skillsAreEqual(cs, this.routine[i])) return false; } return true; },
            skillsAreEqual(sA, sB) { const tA = (sA.twist_distribution || []).reduce((s, t) => s + t, 0); const tB = (sB.twist_distribution || []).reduce((s, t) => s + t, 0); if (tA !== tB || sA.rotation !== sB.rotation || sA.backward !== sB.backward || sA.seat_landing !== sB.seat_landing || sA.takeoff_position !== sB.takeoff_position) return false; if (sA.rotation === 0 && tA === 0) return sA.shape === sB.shape; if (sA.rotation < 3) return true; if (sA.rotation >= 3 && sA.rotation < 6) { if (tA < 2) return sA.shape === sB.shape; return true; } if (sA.shape !== sB.shape) return false; if (sA.rotation >= 7) { const dA = JSON.stringify(sA.twist_distribution || []); const dB = JSON.stringify(sB.twist_distribution || []); if (dA !== dB) return false; } return true; },
            handleDragStart(event, index) { this.draggedIndex = index; this.isDragging = true; event.dataTransfer.effectAllowed = 'move'; setTimeout(() => { const el = event.target.closest('.routine-skill'); if(el) el.classList.add('dragging'); }, 0); },
            handleDragOver(event, index) { event.preventDefault(); if (index !== this.draggedIndex) { const t = event.target.closest('.routine-skill'); document.querySelectorAll('.drop-target-active').forEach(el => el.classList.remove('drop-target-active')); if(t) t.classList.add('drop-target-active'); this.dropIndex = index; } else { this.dropIndex = null; document.querySelectorAll('.drop-target-active').forEach(el => el.classList.remove('drop-target-active')); } return false; },
            handleDragLeave(event) { const t = event.target.closest('.routine-skill'); if (t && !t.contains(event.relatedTarget)) { t.classList.remove('drop-target-active'); if (this.dropIndex === Array.from(t.parentNode.children).indexOf(t)) { this.dropIndex = null; } } },
            handleDrop(event, index) { event.preventDefault(); document.querySelectorAll('.drop-target-active').forEach(el => el.classList.remove('drop-target-active')); const t = event.target.closest('.routine-skill'); const ti = t ? Array.from(t.parentNode.children).indexOf(t) : this.routine.length; if (this.draggedIndex !== null && this.draggedIndex !== ti) { const i = this.routine.splice(this.draggedIndex, 1)[0]; const ii = (this.draggedIndex < ti) ? ti -1 : ti; this.routine.splice(ii, 0, i); if (this.editingIndex !== null) { let o = this.editingIndex; if (o === this.draggedIndex) this.editingIndex = ii; else if (this.draggedIndex < o && ii >= o) this.editingIndex--; else if (this.draggedIndex > o && ii <= o) this.editingIndex++; } } this.draggedIndex = null; this.dropIndex = null; this.isDragging = false; },
            handleDragEnd(event) { try { document.querySelectorAll('.routine-skill.dragging').forEach(el => el.classList.remove('dragging')); document.querySelectorAll('.drop-target-active').forEach(el => el.classList.remove('drop-target-active')); } finally { this.draggedIndex = null; this.dropIndex = null; this.isDragging = false; } },
            handleTouchStart(event, index) { if (event.target.closest('button, .delete')) return; this.draggedIndex = index; this.isDragging = true; this.touchStartY = event.touches[0].clientY; this.draggedElement = event.target.closest('.routine-skill'); if (this.draggedElement) { this.draggedElement.classList.add('dragging'); document.body.classList.add('dragging-touch'); } },
            handleTouchMove(event) { if (this.draggedIndex === null || !this.draggedElement) return;  const touch = event.touches[0]; const cY = touch.clientY; const p = this.draggedElement.parentNode; let ti = null; const children = Array.from(p.children); document.querySelectorAll('.drop-target-active').forEach(el => el.classList.remove('drop-target-active')); for (let i = 0; i < children.length; i++) { const c = children[i]; if (c === this.draggedElement) continue; const r = c.getBoundingClientRect(); if (cY > r.top && cY < r.bottom) { ti = i; c.classList.add('drop-target-active'); break; } } this.dropIndex = ti; },
            handleTouchEnd(event) { if (this.draggedIndex === null || !this.draggedElement) return; this.draggedElement.classList.remove('dragging'); document.body.classList.remove('dragging-touch'); document.querySelectorAll('.drop-target-active').forEach(el => el.classList.remove('drop-target-active')); if (this.dropIndex !== null && this.dropIndex !== this.draggedIndex) { const i = this.routine.splice(this.draggedIndex, 1)[0]; const ii = this.dropIndex; this.routine.splice(ii, 0, i); if (this.editingIndex !== null) { let o = this.editingIndex; if (o === this.draggedIndex) this.editingIndex = ii; else if (this.draggedIndex < o && ii >= o) this.editingIndex--; else if (this.draggedIndex > o && ii <= o) this.editingIndex++; } } this.draggedIndex = null; this.dropIndex = null; this.touchStartY = null; this.draggedElement = null; this.isDragging = false; },
            calculatePhases(rotation) { rotation = Math.abs(rotation); if (rotation <= 6) return 1; if (rotation <= 10) return 2; if (rotation <= 14) return 3; if (rotation > 0) return 4; return 1; },
            getFormData(formSelector) { const form = document.querySelector(formSelector); if (!form) { console.error("getFormData: Form not found!"); return {}; } const fd = new FormData(form); const data = Object.fromEntries(fd.entries()); const bc = form.querySelector('#backward-flag'); data.backward = bc ? bc.checked : false; data.seat_landing = fd.has('seat_landing'); data.rotation = parseInt(data.rotation) || 0; const absR = Math.abs(data.rotation); const nP = this.calculatePhases(absR); const twists = []; const allTwistInputs = form.querySelectorAll('input[name="twist_distribution[]"]'); for (let i = 0; i < nP; i++) { let val = 0; if (allTwistInputs[i] && !allTwistInputs[i].disabled) { val = parseInt(allTwistInputs[i].value) || 0; } twists.push(val); } data.twist_distribution = twists; delete data['twist_distribution[]']; data.name = form.querySelector('#skill-name-display')?.value || 'Custom Skill'; return data; },
            parseFormDataForCalc(formDataObject) { const data = { ...formDataObject }; data.backward = formDataObject.backward === 'on' || formDataObject.backward === true; data.seat_landing = formDataObject.seat_landing === 'on' || formDataObject.seat_landing === true; data.rotation = parseInt(data.rotation) || 0; const absR = Math.abs(data.rotation); const nP = this.calculatePhases(absR); const twists = []; const tVals = formDataObject['twist_distribution[]']; if (Array.isArray(tVals)) { for(let i=0; i<nP && i<tVals.length; i++) { twists.push(parseInt(tVals[i]) || 0); } } else if (tVals !== undefined && nP >= 1) { twists.push(parseInt(tVals) || 0); } while (twists.length < nP) { twists.push(0); } data.twist_distribution = twists.slice(0, nP); delete data['twist_distribution[]']; return data; }

        } // End store
    } // End function
</script>

<style>
    /* Existing styles plus potential additions */
    .routine-skills .box { margin-bottom: 1rem; border-left: 4px solid #ddd; cursor: grab; transition: border-left-color 0.3s ease, opacity 0.2s ease; -webkit-user-select: none; user-select: none; } /* Disable selection */
    .routine-skill.invalid-transition { border-left-color: #ff3860 !important; }
    .routine-skill.invalid-landing { border-left-color: #ff69b4 !important; }
    .routine-skill.duplicate-skill { border-left-color: #ffdd57 !important; }
    .routine-skill.dragging { opacity: 0.4; cursor: grabbing; z-index: 10; } /* Ensure dragging is on top */
    .routine-skill.drop-target-active { border-top: 3px dashed blue !important; }
    .is-fixed-bottom-right { position: fixed; bottom: 1rem; right: 1rem; z-index: 1000; }
    [x-cloak] { display: none !important; }
    /* Prevent selection during drag on mobile */
    /*body.dragging-touch { overscroll-behavior: none; -webkit-user-select: none; user-select: none;}
    /* Ensure buttons inside draggable are clickable on touch */
    .routine-skill button, .routine-skill .delete { pointer-events: auto; }
</style>

{{end}}